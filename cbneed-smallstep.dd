# Overview

This is a small-step semantics for a call-by-need CPS language with lambdas and
datatypes.

I claim this is what you would get if you took the standard AAM Krivine machine
[AAM 2010] and applied a CPS discipline. The CPS transformation is used as a
purely syntactic discipline to:

1. Eliminate administrative, stack-manipulating semantic transitions.
2. Ensure that the only expressions treated lazily are function applications
   and recursive variable references.

# Direct Style Syntax

The source syntax looks like this:

    l   โ Lit
    con โ Symbol
    x   โ Var
    e   โ Exp ::=
      l
      x
      DATA(con,eโ,...,eโ)
      ฮป(x) โ e
      LET x := eโ IN eโ
      LETREC { xโ := eโ ; ... ; xโ := eโ } IN e
      CASE e OF { (conโ,eโโ,...,eโโ) โ eโ ; ... ; (conโ,eโโ,...,eโโ) โ eโ }
      @F(eโ,eโ)

# CPS Syntax

For the CPS syntax we distinguish source variables |Var|, continuation
variables |KVar| and reference variables |RVar|. Although continuation
variables give names to continuation values, continuations are still second
class values and cannot flow to source variable binders. Reference variables
only exist as unique names for reference allocation sites in the abstract
semantics.

    l     โ Lit
    con   โ Symbol
    x     โ Var
    k     โ KVar
    r     โ RVar

The CPS syntax is stratified into |Pico|, |Atom| and |Call| expressions.
|Pico| expressions are a variable or literal; |Atom| expressions are those
which can be computed immediately: lambdas and thunked function application;
and |Call| expressions are those which require arbitrary amounts of computation
to evaluate. |Call| expressions contain nested |Atom| expressions in let
bindings and nested |Pico| expressions in function applications and case
branching (other than the tail |Call| in let and case expressions).

    p โ Pico ::= x | l
    a โ Atom ::= 
      p
      ฮป(x,k) โ c 
      THUNK[r,xแตฃ,k](pโ,pโ)
    ka โ KAtom ::=
      k
      ฮป(x) โ c 
    c โ Call ::= 
      LET x := a IN c
      LET k := ka IN c
      REC [rโ,xแตฃโ,xโ] ... [rโ,xแตฃโ,xโ] IN c
      LETREC { xโ := aโ ; ... ; xโ := aโ } IN c
      @K(k,p)
      @F(pโ,pโ,k)
      CASE(p) OF { (conโ,xโโ,...,xโโ) โ cโ ; ... ; (conโ,xโโ,...,xโโ) โ cโ }
      HALT(p)

The |THUNK[r,xแตฃ,k](p,p)| syntax holds binders:

- |r|: The unique name for allocating the reference cell.
- |xแตฃ|: The name for allocating values that are returned from evaluating the
  reference cell.
- |k|: The name for allocating the continuation that pushes this thunk's
  evaluation on the stack.

The |REC[r,xแตฃ,x]| syntax holds binders:

- |r|: The unique name for allocating the reference cell.
- |xแตฃ|: The name for allocating values taht are returned from evaluating the
  reference cell.
- |x|: The source-level binder name.

# CPS Conversion

The CPS conversion demonstrates how source |LETREC| forms desugar into CPS
|REC| and |LETREC| forms. This CPS conversion take a meta-continuations as an
argument and reifies the meta-continuation when necessary. In the
implementation we do even better, keeping a continuation either meta-level or
object-level and only reifying or reflecting it if necessary.

    CPS : Exp ร (Pico โ Call) โ Call
    CPS(l,k) := k(l)
    CPS(x,k) := k(x)
    CPS(DATA(con,eโ,...,eโ),k) :=
      CPS(eโ,ฮป(pโ) โ ... (CPS(eโ,ฮป(pโ) โ
      LET xโ := pโ IN
      ...
      LET xโ := pโ IN
      LET x  := DATA(con,pโ,...,pโ) IN
      k(x)
        where x fresh
    CPS(ฮป(x) โ e,k) := 
      LET x := ฮป(x,k') โ CPS(e,ฮป(p) โ @K(k',p)) IN
      k(x)
        where x,k' fresh
    CPS(LET x := eโ IN eโ,k) :=
      CPS(eโ,ฮป(p) โ 
      LET x := p IN 
      CPS(eโ,k))
    CPS(LETREC { xโ := eโ ; ... ; xโ := eโ } IN e,k) :=
      REC [rโ,xแตฃโ,xโ] ... [rโ,xแตฃโ,xโ] IN
      CPS(eโ,ฮป(pโ) โ ... (CPS(eโ,ฮป(pโ) โ 
      LETREC { xโ := pโ ; ... ; xโ := pโ } IN
      CPS(e,k))) ... )
        where rโ,xแตฃโ,...,rโ,xแตฃโ fresh
    CPS(CASE(e) OF { (conโ,xโโ,...,xโโ) โ eโ ; (conโ,xโโ,...,xโโ) โ eโ },k) :=
      CPS(e,ฮป(p) โ
      CASE p OF { (conโ,xโโ,...,xโโ) โ CPS(eโ,k) ; (con,xโโ,...,xโโ) โ CPS(eโ,k) })
    CPS(@F(eโ,eโ),k) :=
      CPS(eโ,ฮป(pโ) โ
      CPS(eโ,ฮป(pโ) โ
      LET x := THUNK[r,xแตฃ,k](pโ,pโ) IN
      k(x)))
        where r,xแตฃ,k fresh

Notice that the CPS translation does not create any |@F| expressions. This is
because |@F| is treated as a forcing function call, none of which are present
in the source. Forcing function calls |@F| arise as the result of entering a
thunk, and entering a thunk arises from case expressions or another forcing
function call.

# Concrete Dynamic Semantics

    ฯ     โ Time
    tick  โ Call ร Time โ Time
    ๐     โ Addr
    alloc โ AnyVar ร Time โ Addr

    v โ Val ::= 
      l 
      DATA(con,๐โ,...,๐โ)
      โจฮป(x,k) โ c,ฯโฉ 
      REF[x](r)
    kv โ KVal ::=
      โจฮป(x) โ c,ฯโฉ 
      โจฮป![๐,v](x) โ c,ฯโฉ
    rv โ RVal ::=
      FORCED(v)
      โจTHUNK[k](pโ,pโ),ฯโฉ 

|REF| values contain a reference location (allocated by |r|) which points to
either a forced or thunked value. The second continuation form |โจฮป![๐,v](x) โ
c,ฯโฉ| is just like a standard continuation but with added behavior: before
continuing to its body |c| it looks up the location |๐| and replaces any
occurences of |v| with the bound argument.

    x,k,r โ AnyVar  := Var  โช KVar โช RVar
    p,k,r โ AnyPico := Pico โช KVar โช RVar
    a,k,r โ AnyAtom := Atom โช KVar โช RVar
    v,kv  โ AnyVal  := Val  โช KVal

    ฯ     โ Env     := AnyVar โ Addr
    ฯ     โ Store   := Addr โ AnyVal


The concrete semantics are given through denotation functions |๐แถ| and |๐ซแถ|,
and a small-step transition relation |_~~>แถ_|.

    ๐ซแถ โ AnyPico โ Env ร Store โ AnyVal
    ๐ซแถโฆxโง(ฯ,ฯ) = ฯ(ฯ(x))
    ๐ซแถโฆlโง(ฯ,ฯ) = l

    ๐แถ    โ AnyAtom โ Env ร Store ร Time โ AnyVal ร Store
    ๐แถโฆpโง(ฯ,ฯ,ฯ) = (๐ซแถโฆpโง(ฯ,ฯ),ฯ)
    ๐แถโฆฮป(x,k) โ cโง(ฯ,ฯ,ฯ) = (โจฮป(x,k) โ c,ฯโฉ,ฯ)
    ๐แถโฆTHUNK[r,xแตฃ,k](pโ,pโ)โง(ฯ,ฯ,ฯ) = (REF[xแตฃ](๐แตฃ),ฯ[๐แตฃ โฆ โจTHUNK[k](pโ,pโ),ฯโฉ])
      where ๐แตฃ := alloc(r,ฯ)

The denotation for |THUNK| atmoic expressions evaluates to a new reference cell
with its value bound to a thunk closure.

    ฯ     โ ฮฃ := Call ร Env ร Store ร Time
    _~~>แถ_ โ ฮฃ ร ฮฃ

The let-style commands are simple; they update the environment and store with
new values and proceed to the nested call. |REC-C| creates reference cells for
recursive bindings and |LETREC-C| fills them in.

    [LET-C]
    โจLET x := a IN c,ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ',ฯ'',tick(ฯ)โฉ
      where 
        (v,ฯ') := ๐แถโฆaโง(ฯ,ฯ,ฯ) 
        ๐โ     := alloc(x,ฯ)
        ฯ'     := ฯ[x โฆ ๐โ]
        ฯ''    := ฯ'[๐โ โฆ v]

    [REC-C]
    โจREC [rโ,xแตฃโ,xโ] ... [rโ,xแตฃโ,xโ] IN c,ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ',ฯ',tick(ฯ)โฉ
      where 
        ๐แตฃโ := alloc(rโ,ฯ) , ... , ๐แตฃโ := alloc(rโ,ฯ)
        ๐โโ := alloc(xโ,ฯ) , ... , ๐โโ := alloc(xโ,ฯ)
        ฯ'  := ฯ[xโ โฆ ๐โโ,...,xโ โฆ ๐โโ]
        ฯ'  := ฯ[๐โโ โฆ REF[xแตฃโ](๐แตฃโ),...,๐โโ โฆ REF[xแตฃโ](๐แตฃโ)]

    [LETREC-C]
    โจLETREC { xโ := aโ ; ... ; xโ := aโ } IN c,ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ,ฯ',tick(ฯ)โฉ
      where 
        REF[xแตฃโ](๐โ) := ฯ(ฯ(xโ)) , ... , REF[xแตฃโ](๐โ) := ฯ(ฯ(xโ))
        (vโ,ฯโ)      := ๐แถโฆaโโง(ฯ,ฯ,ฯ) , ... , (vโ,ฯโ) := ๐แถโฆaโโง(ฯ,ฯโโโ,ฯ) 
        ฯ'           := ฯโ[๐โ โฆ vโ,...,๐โ โฆ vโ]

Continuation applications continue with the continuation body and environment.
The |KON-MEMO-C| rule implements the semantics of memoization. The set
difference with |[๐' โฆ v]| in [KON-MEMO-C] is redundant because the new value
will overwrite the old one, but its abstraction will become meaningful and
important in the abstract semantics.

    [KON-C]
    โจ@K(pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ'',ฯ',ฯ)],tick(ฯ)โฉ
      where 
        โจฮป(x) โ c,ฯ'โฉ := ๐ซแถโฆpโโง(ฯ,ฯ)
        ๐โ            := alloc(x,ฯ)
        ฯ''           := ฯ'[x โฆ ๐โ]
        ฯ'            := ฯ[๐โ โฆ ๐ซแถโฆpโโง(ฯ,ฯ)]

    [KON-MEMO-C]
    โจ@K(pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ'',ฯ',tick(ฯ)โฉ
      where 
        โจฮป![๐,v](x) โ c,ฯ'โฉ := ๐ซแถโฆpโโง(ฯ,ฯ)
        ๐โ                  := alloc(x,ฯ)
        ฯ''                 := ฯ'[x โฆ ๐โ]
        ฯ'                  := (ฯ โฉ ยฌ[๐' โฆ v])[๐โ โฆ ๐ซแถโฆpโโง(ฯ,ฯ),๐ โฆ ๐ซแถโฆpโง(ฯ,ฯ)]

Function application has three cases:

1. The first atom is a function, in which case the function is applied.
2. The first atom is a forced value, in which case the value is retrieved and
   the application is attempted again.
2. The first atom is a thunk, in which case the thunk is jumped to and the
   current application context is pushed on the stack.

    [FUN-VAL-C]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แถ โจc,ฯ'',ฯ',tick(ฯ)โฉ
      where 
        โจฮป(x,k) โ c,ฯ'โฉ := ๐ซแถโฆpโโง(ฯ,ฯ)
        ๐โ              := alloc(x,ฯ) 
        ๐โ              := alloc(k,ฯ)
        ฯ''             := ฯ'[x โฆ ๐โ,k โฆ ๐โ]
        ฯ'              := ฯ[๐โ โฆ ๐ซแถโฆpโโง(ฯ,ฯ),๐โ โฆ ๐ซแถโฆpโโง(ฯ,ฯ)]

    [FUN-FORCED-C]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แถ โจ@F(x,pโ,pโ),ฯ',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐) := ๐ซแถโฆpโโง(ฯ,ฯ)
        FORCED(v) := ฯ(๐) 
        ๐โ        := alloc(x,ฯ)
        ฯ'        := ฯ[x โฆ ๐โ]
        ฯ'        := ฯ[๐โ โฆ v]

    [FUN-THUNK-C]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แถ โจ@F(pโ',pโ',k),ฯ'[k โฆ ๐โ],ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)              := ๐ซแถโฆpโโง(ฯ,ฯ)
        โจTHUNK[k](pโ',pโ'),ฯ'โฉ := ฯ(๐) 
        ๐โ                     := alloc(k,ฯ)
        ฯ''                    := ฯ'[k โฆ ๐โ]
        ฯ'                     := ฯ[๐โ โฆ โจฮป![๐,ฯ(๐)](x) โ @F(x,pโ,pโ),ฯโฉ]

Case expressions similarly have three cases:

1. The atom is a data construction, in which case the case branch is executed.
2. The atom is a forced value, in which case the value is retrieved and the
   case is attempted again.
2. The atom is a thunk, in which case the thunk is jumped to and the
   current case context is pushed on the stack.

    [CASE-VAL-C]
    โจCASE(p) OF { conโ(xโโ,...,xโโ) โ cโ ; ... ; conแตข(xแตขโ,...,xแตขโ) โ cแตข ; ... ; conโ(xโโ,...,xโโ) โ cโ},ฯ,ฯ,ฯโฉ ~~>แถ โจcแตข,ฯ',ฯ',tick(ฯ)โฉ
      where 
        DATA(conแตข,๐โ,...,๐โ) := ๐ซแถโฆpโง(ฯ,ฯ)
        ๐โโ                  := alloc(xแตขโ,ฯ) , ... , ๐โโ := alloc(xแตขโ,ฯ)
        ฯ'                   := ฯ[xแตขโ โฆ ๐โโ,...,xแตขโ โฆ ๐โโ]
        ฯ'                   := ฯ[๐โโ โฆ ฯ(๐โ),...,๐โโ โฆ ฯ(๐โ)]

    [CASE-FORCED-C]
    โจCASE(p) OF { alts },ฯ,ฯ,ฯโฉ ~~>แถ โจCASE(x) OF { alts },ฯ',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐) := ๐ซแถโฆpโง(ฯ,ฯ)
        FORCED(v) := ฯ(๐) 
        ๐โ        := alloc(x,ฯ)
        ฯ'        := ฯ[x โฆ ๐โ]
        ฯ'        := ฯ[๐โ โฆ v]

    [CASE-THUNK-C]
    โจCASE(p) OF { alts },ฯ,ฯ,ฯโฉ ~~>แถ โจ@F(pโ',pโ',k),ฯ'',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)              := ๐ซแถโฆpโง(ฯ,ฯ)
        โจTHUNK[k](pโ',pโ'),ฯ'โฉ := ฯ(๐) 
        ๐โ                     := alloc(k,ฯ)
        ฯ''                    := ฯ'[k โฆ ๐โ]
        ฯ'                     := ฯ[๐โ โฆ โจฮป![๐,ฯ(๐)](x) โ CASE(x) OF { alts },ฯโฉ]

The notation in |CASE-VAL-C| is a little strange. |conแตข| matches with the i'th
constructor in the sequence of |Alt| expressions and |xแตขโ,...,xแตขโ| is the
sequence of binders attached to that branch.

# Abstract Dynamic Semantics

The abstract semantics are just like the concrete semantics except:

1. It is non-deterministic.
2. It is approximating--values are merged into the store rather than updated.

These two characteristics allow for (or arise from) making the state space
finite, which is essential for a computable analysis.

For simplicity, it is assumed that the value space is abstracted as a powerset
of concrete values. This does not yet yield a finite state space, but going
from powerset to something finite with a lattice structure is a simple matter
of replace union and intersection (|โช| and |โฉ|) with join and meet (|โ| and
|โ|). We still write join (|โ|) when merging two stores, which will perform a
union (|โช|) on value sets in the codomain. Notationally we write |v| to range
over values and capitalized as |V| to range over powersets of values.

The only difference between the abstract semantics are a replacement of |:=|
with |โ| when evaluating pico expressions with |๐ซ|, and updating the store
monotonically with join (|โ|) rather than with replacement.

    ฯ โ Store := Addr โ โ(AnyVal)

    ๐ซแต : Pico โ (Env ร Store) โ โ(AnyVal)
    ๐ซแตโฆxโง(ฯ,ฯ) = ฯ(ฯ(x))
    ๐ซแตโฆlโง(ฯ,ฯ) = {l}

    ๐แต : Atom โ Env ร Store ร Time โ โ(AnyVal) ร Store
    ๐แตโฆpโง(ฯ,ฯ,ฯ) = (๐ซแตโฆpโง(ฯ,ฯ),ฯ)
    ๐แตโฆฮป(x,k) โ cโง(ฯ,ฯ,ฯ) = ({โจฮป(x,k) โ c,ฯโฉ},ฯ)
    ๐แตโฆTHUNK[r,xแตฃ,k](pโ,pโ)โง(ฯ,ฯ,ฯ) = ({REF[xแตฃ](๐แตฃ)},ฯ โ [๐แตฃ โฆ โจTHUNK[k](pโ,pโ),ฯโฉ])
      where ๐แตฃ := alloc(r,ฯ)

    [LET-A]
    โจLET x := a IN c,ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ',ฯ'',tick(ฯ)โฉ
      where 
        (V,ฯ') := ๐แตโฆaโง(ฯ,ฯ,ฯ) 
        ๐โ     := alloc(x,ฯ)
        ฯ'     := ฯ[x โฆ ๐โ]
        ฯ''    := ฯ' โ [๐โ โฆ v]

    [REC-A]
    โจREC [rโ,xแตฃโ,xโ] ... [rโ,xแตฃโ,xโ] IN c,ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ',ฯ',tick(ฯ)โฉ
      where 
        ๐แตฃโ := alloc(rโ,ฯ) , ... , ๐แตฃโ := alloc(rโ,ฯ)
        ๐โโ := alloc(xโ,ฯ) , ... , ๐โโ := alloc(xโ,ฯ)
        ฯ'  := ฯ[xโ โฆ ๐โโ,...,xโ โฆ ๐โโ]
        ฯ'  := ฯ โ [๐โโ โฆ REF[xแตฃโ](๐แตฃโ),...,๐โโ โฆ REF[xแตฃโ](๐แตฃโ)]

    [LETREC-A]
    โจLETREC { xโ := aโ ; ... ; xโ := aโ } IN c,ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ,ฯ',tick(ฯ)โฉ
      where 
        REF[xแตฃโ](๐โ)  โ ฯ(ฯ(xโ)) , ... , REF[xแตฃโ](๐โ)  โ ฯ(ฯ(xโ))
        (Vโ,ฯโ)      := ๐แตโฆaโโง(ฯ,ฯ,ฯ) , ... , (vโ,ฯโ) := ๐แตโฆaโโง(ฯ,ฯโโโ,ฯ) 
        ฯ'           := ฯโ โ [๐โ โฆ vโ,...,๐โ โฆ vโ]

    [KON-A]
    โจ@K(pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ'',ฯ',ฯ)],tick(ฯ)โฉ
      where 
        โจฮป(x) โ c,ฯ'โฉ  โ ๐ซแตโฆpโโง(ฯ,ฯ)
        ๐โ            := alloc(x,ฯ)
        ฯ''           := ฯ'[x โฆ ๐โ]
        ฯ'            := ฯ โ [๐โ โฆ ๐ซแตโฆpโโง(ฯ,ฯ)]

    [KON-MEMO-A]
    โจ@K(pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ'',ฯ',tick(ฯ)โฉ
      where 
        โจฮป![๐,v](x) โ c,ฯ'โฉ  โ ๐ซแตโฆpโโง(ฯ,ฯ)
        ๐โ                  := alloc(x,ฯ)
        ฯ''                 := ฯ'[x โฆ ๐โ]
        ฯ'                  := (ฯ โ ยฌ[๐' โฆ v]) โ [๐โ โฆ ๐ซแตโฆpโโง(ฯ,ฯ),๐ โฆ ๐ซแตโฆpโง(ฯ,ฯ)]

    [FUN-VAL-A]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แต โจc,ฯ'',ฯ',tick(ฯ)โฉ
      where 
        โจฮป(x,k) โ c,ฯ'โฉ  โ ๐ซแตโฆpโโง(ฯ,ฯ)
        ๐โ              := alloc(x,ฯ) 
        ๐โ              := alloc(k,ฯ)
        ฯ''             := ฯ'[x โฆ ๐โ,k โฆ ๐โ]
        ฯ'              := ฯ โ [๐โ โฆ ๐ซแตโฆpโโง(ฯ,ฯ),๐โ โฆ ๐ซแตโฆpโโง(ฯ,ฯ)]

    [FUN-FORCED-A]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แต โจ@F(x,pโ,pโ),ฯ',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)  โ ๐ซแตโฆpโโง(ฯ,ฯ)
        FORCED(v)  โ ฯ(๐) 
        ๐โ        := alloc(x,ฯ)
        ฯ'        := ฯ[x โฆ ๐โ]
        ฯ'        := ฯ โ [๐โ โฆ v]

    [FUN-THUNK-A]
    โจ@F(pโ,pโ,pโ),ฯ,ฯ,ฯโฉ ~~>แต โจ@F(pโ',pโ',k),ฯ'[k โฆ ๐โ],ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)               โ ๐ซแตโฆpโโง(ฯ,ฯ)
        โจTHUNK[k](pโ',pโ'),ฯ'โฉ  โ ฯ(๐) 
        ๐โ                     := alloc(k,ฯ)
        ฯ''                    := ฯ'[k โฆ ๐โ]
        ฯ'                     := ฯ โ [๐โ โฆ โจฮป![๐,ฯ(๐)](x) โ @F(x,pโ,pโ),ฯโฉ]

    [CASE-VAL-A]
    โจCASE(p) OF { conโ(xโโ,...,xโโ) โ cโ ; ... ; conแตข(xแตขโ,...,xแตขโ) โ cแตข ; ... ; conโ(xโโ,...,xโโ) โ cโ},ฯ,ฯ,ฯโฉ ~~>แต โจcแตข,ฯ',ฯ',tick(ฯ)โฉ
      where 
        DATA(conแตข,๐โ,...,๐โ)  โ ๐ซแตโฆpโง(ฯ,ฯ)
        ๐โโ                  := alloc(xแตขโ,ฯ) , ... , ๐โโ := alloc(xแตขโ,ฯ)
        ฯ'                   := ฯ[xแตขโ โฆ ๐โโ,...,xแตขโ โฆ ๐โโ]
        ฯ'                   := ฯ โ [๐โโ โฆ ฯ(๐โ),...,๐โโ โฆ ฯ(๐โ)]

    [CASE-FORCED-A]
    โจCASE(p) OF { alts },ฯ,ฯ,ฯโฉ ~~>แต โจCASE(x) OF { alts },ฯ',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)  โ ๐ซแตโฆpโง(ฯ,ฯ)
        FORCED(v)  โ ฯ(๐) 
        ๐โ        := alloc(x,ฯ)
        ฯ'        := ฯ[x โฆ ๐โ]
        ฯ'        := ฯ โ [๐โ โฆ v]

    [CASE-THUNK-A]
    โจCASE(p) OF { alts },ฯ,ฯ,ฯโฉ ~~>แต โจ@F(pโ',pโ',k),ฯ'',ฯ',tick(ฯ)โฉ
      where 
        REF[x](๐)               โ ๐ซแตโฆpโง(ฯ,ฯ)
        โจTHUNK[k](pโ',pโ'),ฯ'โฉ  โ ฯ(๐) 
        ๐โ                     := alloc(k,ฯ)
        ฯ''                    := ฯ'[k โฆ ๐โ]
        ฯ'                     := ฯ โ [๐โ โฆ โจฮป![๐,ฯ(๐)](x) โ CASE(x) OF { alts },ฯโฉ]
