# TODO

- Add the caching/memoization

# Syntax

Note that for this semantics, continuation and computation variables,
expressions and values are distinguished syntactically. In the semantics, they
are not distinguished, i.e. the runtime store maps any variable to any value.
It is true, however, that continuation variables only take on continuation
values, and likewise for computation variables/values.

We assume arbitrary sets of literals, constructor tags and variables.
Continuation variables are distinguished syntactically from computation
variables.

    l   âˆˆ Lit
    con âˆˆ Symbol
    x   âˆˆ Var
    k   âˆˆ KVar
    x,k âˆˆ AnyVar := Var âˆª KVar

|Pico| expressions are either a name or syntactic literal. |Pico| is the only
syntactic category which may appear nested in |Call| expresssions.

    p âˆˆ Pico ::= x | l
    p,k âˆˆ AnyPico := Pico âˆª KVar

|Atom| expressions are those which have an immediate evaluation or denotation.
|Atom| expressions must be let-bound to a name to be used in a |Call|
expression. Continuation atoms, that is those which will be bound to
continuation variables, are distinguished syntactically.

  a âˆˆ Atom ::= 
    p
    Î»(x,k) â†’ c 
    THUNK[x,k](p,p)
  ka âˆˆ KAtom ::=
    k
    Î»(x) â†’ c 
  a,ka âˆˆ AnyAtom := Atom âˆª KAtom


|Call| expressions are GHC core expressions which require no meta-language
stack (have been CPS'd) and give rise to a simple CES machine.

  alt âˆˆ Alt ::= con(x,...) â†’ c
  c âˆˆ Call ::= 
    LET x := a IN c
    LET k := ka IN c
    REC x ... IN c
    LETREC { x := a ; ... } IN c
    @K(k,p)
    @F(p,p,k)
    CASE(p) OF { alt ; ... }
    HALT(p)

The |REC| and |LETREC| constructs are the results of the CPS transformation on
|letrec| source expressions. They are slightly imperative in that, in the
dynamic semantics, |REC| puts lazy references to the variables into the store
and |LETREC| imperatively updates these to be values.

The |@F| construct is for forced function applications. Source function
applications translate into |LET x := THUNK[x,k](pâ‚,pâ‚‚) IN ...| and |@F| only
appears when a thunk appeared where a forced value was expected, and the
thunked function application is evaluated.

# Dynamic Semantics

We assume arbitrary sets of time and address values. Time values can be
advanced forward using |tick| and addresses can be created from a time using
|alloc|.

    Ï„     âˆˆ Time
    tick  âˆˆ Call Ã— Time â†’ Time
    ğ“     âˆˆ Addr
    alloc âˆˆ AnyVar Ã— Time â†’ Addr

Values are either a literal, a data construction, a function closure, a thunk, or a
delayed variable reference. Continuation values are distinguished syntactically
and are either a continuation closure, a case expression continuation, or a
function application continuation.

  d âˆˆ Data ::= 
    CON(con,ğ“,...)
  v âˆˆ Val ::= 
    l 
    d 
    âŸ¨Î»(x,k) â†’ c,ÏâŸ© 
    âŸ¨THUNK[x,k](x,x),ÏâŸ© 
    DELAY(ğ“)
  kv âˆˆ KVal ::=
    âŸ¨Î»(x) â†’ c,ÏâŸ© 
  v,kv âˆˆ AnyVal := Val âˆª KVal

Atoms and picos have straightforward denotation functions.

    ğ’œ âˆˆ AnyAtom â†’ (Env â†’ AnyVal)
    ğ’« âˆˆ AnyPico â†’ (Env â†’ AnyVal)

An element of the state space, called a configuration, holds an environment, a
store and the current time.

    Ï âˆˆ Env   := AnyVar â‡€ Addr
    Ïƒ âˆˆ Store := Addr â‡€ AnyVal
    Ï‚ âˆˆ Î£     ::= 
      âŸ¨c,Ï,Ïƒ,Ï„âŸ©

The step relation |_~~>_| is a small-step relation between configurations.

    _~~>_ âˆˆ Î£ Ã— Î£

The let-style commands are simple; they update the environment and store with
new values and proceed to the nested call.

    [LET]
    âŸ¨LET x := a IN c,Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨c,Ï[x â†¦ ğ“],Ïƒ[ğ“ â†¦ ğ’œ âŸ¦aâŸ§(Ï)],tick(Ï„)âŸ©
      where ğ“ := alloc(x,Ï„)

    [REC]
    âŸ¨REC xâ‚ ... IN c,Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨c,Ï[xâ‚ â†¦ ğ“â‚,...],Ïƒ[ğ“â‚ â†¦ DELAY(ğ“â‚),...],tick(Ï„)âŸ©
      where ğ“â‚ := alloc(xâ‚,Ï„) and ...

    [LETREC]
    âŸ¨LETREC { xâ‚ := aâ‚ ; ... } IN c,Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨c,Ï,Ïƒ[Ï(xâ‚) â†¦ ğ’œ âŸ¦aâ‚âŸ§(Ï),...],tick(Ï„)âŸ©

Continuation applications proceed by evaluating the first pico value to a
continuation value and continuing to the continuation body under an updated
closure environment. There are no rules for |THUNK| or |DELAY| because these
values never flow to continuation position. The notation |<<pat â† E[â–¡]>>| is
shorthand for "E[x] ... where pat := x".

    [Kon]
    âŸ¨@K(<<âŸ¨Î»(x) â†’ c,Ï'âŸ© â† ğ’«âŸ¦â–¡âŸ§(Ï)>>,pâ‚‚),Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨c,Ï'[x â†¦ ğ“],Ïƒ[ğ“ â†¦ ğ’«âŸ¦pâ‚‚âŸ§(Ï)],tick(Ï„)âŸ©
      where ğ“ := alloc(x,Ï„)

Function application has three cases:

1. The first atom is a function, in which case the function is applied.
2. The first atom is a |THUNK|, in which case the thunk is jumped to and the
   current application context is pushed on the stack.
3. The first atom is a |DELAY|, in which case the value at the delayed address
   is evaluated and bound to a name which replaces the |DELAY| in the
   configuration.

    [FUN-FORCED]
    âŸ¨@F(<<âŸ¨Î»(x,k) â†’ c,Ï'âŸ© â† ğ’«âŸ¦â–¡âŸ§(Ï)>>,pâ‚‚,pâ‚ƒ),Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨c,Ï'[x â†¦ ğ“â‚“ , k â†¦ ğ“â‚–],Ïƒ[ğ“â‚“ â†¦ ğ’«âŸ¦pâ‚‚âŸ§(Ï),ğ“â‚– â†¦ ğ’«âŸ¦pâ‚ƒâŸ§(Ï)],tick(Ï„)âŸ©
      where ğ“â‚“ := alloc(x,Ï„) and ğ“â‚– := alloc(k,Ï„)

    [FUN-THUNK]
    âŸ¨@F(<<âŸ¨THUNK[x,k](pâ‚',pâ‚‚'),Ï'âŸ© â† ğ’«âŸ¦â–¡âŸ§(Ï)>>,pâ‚,pâ‚‚),Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨@F(pâ‚',pâ‚‚',k),Ï'[k â†¦ ğ“],Ïƒ[ğ“ â†¦ âŸ¨Î»(x) â†’ @F(x,pâ‚,pâ‚‚),ÏâŸ©],tick(Ï„)âŸ©
      where ğ“ := alloc(k,Ï„)

    [FUN-DELAY]
    âŸ¨@F(<<DELAY[x](ğ“) â† ğ’«âŸ¦â–¡âŸ§(Ï)>>,pâ‚,pâ‚‚),Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨@F(x,pâ‚‚,pâ‚‚),Ï[x â†¦ ğ“â‚“],Ïƒ[ğ“â‚“ â†¦ Ïƒ(ğ“)],tick(Ï„)âŸ©
      where ğ“â‚“ = alloc(x,Ï„)

Case expressions similarly have three cases:

1. The first atom is a data construction, in which case the case branch is executed.
2. The first atom is a |THUNK|, in which case the thunk is jumped ot and the
   current case context is pushed on the stack.
3. The first atom is a |DELAY|, in which case the value at the delayed address
    is evaluated and bound to a name which replaces the |DELAY| in the
    configuration.

    [CASE-FORCED]
    âŸ¨CASE(<<CON(conáµ¢,ğ“â‚,...) â† ğ’«âŸ¦â–¡âŸ§(Ï)>>) OF { conâ‚(xâ‚â‚,...) â†’ câ‚ ; ... },Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨cáµ¢,Ï[xáµ¢â‚ â†¦ ğ“â‚“â‚,...],Ïƒ[ğ“â‚“â‚ â†¦ Ïƒ(ğ“â‚),...],tick(Ï„)âŸ©
      where ğ“â‚“â‚ := alloc(xáµ¢â‚,Ï„) and ...

    [CASE-THUNK]
    âŸ¨CASE(<<âŸ¨THUNK[x,k](xâ‚,xâ‚‚),Ï'âŸ© â† ğ’«âŸ¦â–¡âŸ§(Ï)>>) OF { alt ... },Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨@F(xâ‚,xâ‚‚,k),Ï'[k â†¦ ğ“],Ïƒ[ğ“ â†¦ âŸ¨Î»(x) â†’ CASE(x) OF { alt ... },ÏâŸ©],tick(Ï„)âŸ©
      where ğ“ := alloc(k,Ï„)

    [CASE-DELAY]
    âŸ¨CASE(<<DELAY[x](ğ“) â† ğ’«âŸ¦â–¡âŸ§(Ï)>>) OF { alt ... },Ï,Ïƒ,Ï„âŸ© ~~> âŸ¨CASE(x) OF { alt ... },Ï[x â†¦ ğ“â‚“],Ïƒ[ğ“â‚“ â†¦ Ïƒ(ğ“)],tick(Ï„)âŸ©
      where ğ“â‚“ := alloc(x,Ï„)

The notation in |CASE-FORCED| is a little strange. |conáµ¢| matches with the i'th
constructor in the sequence of |Alt| expressions and |xáµ¢â‚ ...| is the sequence
of binders attached to that branch.
